**Standard Server**

## How to Switch Between Client Selection Functions

One of the features provided with the server from MiniNetFED is the ability to switch between client selection functions or implement new ones.

Client selection functions are all encapsulated in a Class.

To switch between client selection functions, access the following file:

```
./server/clientSelection/__init__.py
```

In this file, edit the name of the file from which you want to import the function and the name of the implemented Class.

Example:

```python
from .fed_sec_per import FedSecPer as ClientSelection
```

**Important Notes:** Do not alter **as ClientSelection**. It ensures that all server components recognize this function correctly, regardless of the chosen function.

Also note that, as shown, new functions must be encapsulated in a Class and contained in the /server/clientSelection directory.

## How to Implement New Client Selection Functions

To implement a new client selection function, create a new file in the /clientSelection directory with the desired name. Then, create a class with the following pattern:

```python
class FunctionNameOfClientSelection:
    def __init__(self):
      '''
      Define constants if necessary
      '''

    def select_trainers_for_round(self, trainer_list, metrics):
      '''
      Implement the function
      '''
      return selected_list


```

The parameter _trainer_list_ is a list of all available clients to be selected for the next round. _metrics_ is a dictionary generated by the method _all_metrics_ implemented in Trainer. The elements of this dictionary can be accessed with the client IDs from _trainer_list_. _selected_list_ is the list of IDs of trainers selected.

The examples provided with MiniNetFED illustrate how the implementation should be done and can be used as a base for building new ones.

## How to Switch Between Aggregation Functions

In the server provided with MiniNetFED, it is also possible to select between aggregation functions left as an example or implement new ones.

Aggregation functions are all encapsulated in a Class.

To switch between aggregation functions, access the following file:

```
./server/aggregator/__init__.py
```

In this file, edit the name of the file from which you want to import the function and the name of the implemented Class.

Example:

```python
from .fed_avg import FedAvg as Aggregator
```

**Important Notes:** Do not alter **as Aggregator**. It ensures that all server components recognize this function correctly, regardless of the chosen function.

Also note that, as shown, new functions must be encapsulated in a Class and contained in the /server/aggregator directory.

## How to Implement New Aggregation Functions

To implement a new aggregation function, create a new file in the /aggregator directory with the desired name. Then, create a class with the following pattern:

```python
class NameOfAggregator:
    def __init__(self):
      '''
      Initialize constants if necessary
      '''

    def aggregate(self, all_trainer_samples, all_weights):
        '''
        Aggregation function
        '''

        return agg_weights


```

The parameter _all_trainer_samples_ is an array of dictionaries generated by the method _all_metrics_ implemented in Trainer. The elements of this array are arranged in the same order as the weights of each client are in the array _all_weights_.

The examples provided with MiniNetFED illustrate how the implementation should be done and can be used as a base for building new ones.